C51 COMPILER V9.60.0.0   MAIN                                                              06/25/2025 11:40:12 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\UV4\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst
                    -) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "System.h"
   2          
   3          u8 password[3][8] = {{2,2,4,4,6,6,8,8},{1,2,3,4,5,6,7,8},{0,0,0,0,0,0,0,0}};//ç³»ç»Ÿå·²å‚¨å­˜çš„å¯†ç ï¼Œä
             -¸Šç”µä¼šæ›¿æ¢æˆE2PROMçš„
   4          u8 admin[8] = {8,8,8,8,8,8,8,8};//ç®¡ç†å‘˜ä¸‡èƒ½å¯†ç 
   5          u8 pw_input[8] = {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40};//ç”¨æˆ·è¾“å…¥çš„å¯†ç ï¼Œç”¨äºå¯¹ç…§ï¼Œç™»å½•
             -æ— æ•°æ®é»˜è®¤ä¸º0x40ï¼Œä¿®æ”¹æ— æ•°æ®é»˜è®¤ä¸º0x80
   6          u8 pw_index = 8;//è¾“å…¥å¯†ç ä¸‹æ ‡ï¼ŒæŒ‡å‘8æ—¶è¾“å…¥å¯†ç ä¸ºç©º
   7          char user = -1;//ç™»å½•çš„ç”¨æˆ·ID(012ã€‚-1è¡¨ç¤ºæœªç™»å½•,3è¡¨ç¤ºç®¡ç†å‘˜)
   8          u8 error = 0;//é”™è¯¯æ€»æ¬¡æ•°ï¼Œè¶…è¿‡3è¯»ç§’
   9          
  10          u8 mode = 0;//æ¨¡å¼åˆ‡æ¢æ ‡å¿—ä½ï¼Œæ¨¡å¼0è¾“å…¥å¯†ç ï¼Œæ¨¡å¼1å¯†ç æ­£ç¡®å¯ä¿®æ”¹è‡ªå·±çš„å¯†ç ï¼Œ
             -æ¨¡å¼2ç®¡ç†å‘˜æ¨¡å¼å¯ä¿®æ”¹å…¨å‘˜å¯†ç 
  11          // bit flash;//0.1sä¸€é—ª
  12          bit errflag;//é”™è¯¯æ ‡å¿—ä½
  13          bit adflag = 1;//ç®¡ç†å‘˜å­æ¨¡å¼ï¼ˆ0æ—¶é€‰æ‹©IDï¼Œ1æ—¶ä¿®æ”¹å…¶IDï¼‰
  14          bit beepflag;//èœ‚é¸£å™¨å•å“æ ‡å¿—ä½
  15          
  16          u8 segcnt = 0;//100
  17          u8 kbdcnt = 0;//10
  18          // u16 flashcnt = 0;//500
  19          u8 keycnt;
  20          u16 errcnt = 0;//å€’è®¡æ—¶é‡æ–°è¾“å…¥5s
  21          u8 beepcnt;//è®©èœ‚é¸£å™¨å“ä¸€å£°0.075s
  22          bit stepflag;//æ­¥è¿›ç”µæœºæ¯æ­¥å»¶æ—¶ï¼ˆè®¾ä¸º1ï¼‰
  23          
  24          void KBD_Process()
  25          {
  26   1        if(kbdcnt)  return;
  27   1        kbdcnt = 1;
  28   1      
  29   1        KBD_Read();
  30   1      
  31   1        if(error >= 3)//è¶…è¿‡ä¸‰æ¬¡ï¼Œåœæ­¢æ˜¾ç¤ºï¼Œç¦æ­¢è¾“å…¥
  32   1          return;
  33   1      
  34   1        switch(mode){
  35   2          case 0:{//è¾“å…¥å¯†ç æ¨¡å¼
  36   3            //è¾“å…¥æ•°å­—
  37   3                  mPW_Main();
  38   3      
  39   3                  if(pres == 0x11){//ç¡®è®¤å¯†ç 
  40   4              if(mPW_IsEmpty()) return;
  41   4              if(mPW_IsAdmin()){
  42   5                mPW_Clear();
  43   5                Open_Door();
  44   5                //å¯†ç æ­£ç¡®ï¼Œåˆ‡æ¢åˆ°æ¨¡å¼2
  45   5                error = 0;
  46   5                mode = 2;
  47   5                user = 0;
  48   5                SEG_Clear();
  49   5                seg_buf[0] = tab[10]|0x80;//"A."è¡¨ç¤ºå½“å‰åœ¨Adminæ¨¡å¼
  50   5              }
  51   4              else if(mPW_IsCorrect()){
C51 COMPILER V9.60.0.0   MAIN                                                              06/25/2025 11:40:12 PAGE 2   

  52   5                mPW_Clear();
  53   5                Open_Door();
  54   5                //å¯†ç æ­£ç¡®ï¼Œåˆ‡æ¢åˆ°æ¨¡å¼1
  55   5                error = 0;
  56   5                if(user != -1){
  57   6                  mode = 1;
  58   6                  SEG_Clear();
  59   6                  seg_buf[0] = tab[12]|0x80;//"C."è¡¨ç¤ºå½“å‰åœ¨Clientæ¨¡å¼
  60   6                }
  61   5              }
  62   4              else{
  63   5                mPW_Clear();
  64   5                //å¯†ç é”™è¯¯ï¼Œæ¸…ç©ºè¾“å…¥
  65   5                beepflag = 1;
  66   5                error++;
  67   5              }return;
  68   4            }
  69   3      
  70   3            if(pres == 0x21)  mPW_Del();//åˆ é™¤å¯†ç 
  71   3            
  72   3            if(cont == 0x41){//é•¿æŒ‰æ¸…ç©ºå¯†ç 
  73   4              keycnt++;
  74   4              if(keycnt >= 100){
  75   5                mPW_Clear();
  76   5              }
  77   4            }
  78   3      
  79   3            if(keycnt && cont == 0x00){
  80   4              keycnt = 0;
  81   4            }
  82   3          };break;
  83   2          case 1:{//ä¿®æ”¹å¯†ç æ¨¡å¼
  84   3            //è¾“å…¥æ•°å­—
  85   3            mPW_Main();
  86   3      
  87   3            if(pres == 0x21)  mPW_Del();//åˆ é™¤å¯†ç 
  88   3            
  89   3            if(cont == 0x41){//é•¿æŒ‰æ¸…ç©ºå¯†ç 
  90   4              keycnt++;
  91   4              if(keycnt >= 100){
  92   5                mPW_Clear();
  93   5              }
  94   4            }
  95   3      
  96   3            if(keycnt && cont == 0x00){
  97   4              keycnt = 0;
  98   4            }
  99   3            
 100   3            if(pres == 0x11){//ç¡®è®¤ä¿®æ”¹å¯†ç 
 101   4              if(mPW_IsEmpty()) return;
 102   4              mPW_Set();
 103   4              EEPROM_Write(pw_input,user*8,8);//å†™å…¥ä¿®æ”¹åå¯†ç 
 104   4              return;
 105   4            }
 106   3          };break;
 107   2          case 2:{//ç®¡ç†å‘˜æ¨¡å¼
 108   3              if(adflag){//ç•Œé¢1é€‰æ‹©ID
 109   4              if(pres == 0x28)
 110   4                if(user != USER_MAX)
 111   4                  user += 1;//å‘ä¸Šç¿»é¡µ
 112   4                else
 113   4                  user = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              06/25/2025 11:40:12 PAGE 3   

 114   4              if(pres == 0x18)
 115   4                if(user != 0)
 116   4                  user -= 1;//å‘ä¸‹ç¿»é¡µ
 117   4                else
 118   4                  user = USER_MAX;//ç½®ä¸ºç®¡ç†å‘˜ä¸‹æ ‡
 119   4            }
 120   3            else{
 121   4              mPW_Main();
 122   4      
 123   4              if(pres == 0x21)  mPW_Del();//åˆ é™¤å¯†ç 
 124   4              
 125   4              if(cont == 0x14){//é•¿æŒ‰æ˜¾ç¤ºæ—§å¯†ç 
 126   5                  if(user != USER_MAX){
 127   6                  keycnt++;
 128   6                  if(keycnt >= 100){
 129   7                    mPW_Observe();
 130   7                  }
 131   6                }
 132   5              }
 133   4      
 134   4              if(cont == 0x41){//é•¿æŒ‰æ¸…ç©ºå¯†ç 
 135   5                keycnt++;
 136   5                if(keycnt >= 100){
 137   6                  mPW_Clear();
 138   6                }
 139   5              }
 140   4      
 141   4              if(keycnt && cont == 0x00){
 142   5                keycnt = 0;
 143   5              }
 144   4      
 145   4              if(pres == 0x11){//ç¡®è®¤ä¿®æ”¹å¯†ç 
 146   5                if(mPW_IsEmpty()) return;
 147   5      
 148   5                if(user == USER_MAX){//USER_MAXä¸ºç®¡ç†å‘˜ä¸‹æ ‡
 149   6                  mPW_AdminSet();
 150   6                  EEPROM_Write(pw_input,USER_MAX*8,8);
 151   6                }
 152   5                else{
 153   6                  mPW_Set();
 154   6                  EEPROM_Write(password[user],user*8,8);//å†™å…¥ä¿®æ”¹åå¯†ç 
 155   6                }
 156   5                return;
 157   5              }
 158   4            }
 159   3            if(pres == 0x12){//åˆ‡æ¢æ ‡å¿—ä½ä¾¿äºå¤šç”¨æˆ·ç®¡ç†
 160   4              mPW_Clear();
 161   4              adflag = ~adflag;
 162   4            }
 163   3          }
 164   2        }
 165   1      
 166   1        if(pres == 0x81){//é€€å‡ºç™»å½•
 167   2          mPW_Clear();
 168   2          mode = 0;
 169   2          user = -1;
 170   2        }
 171   1      
 172   1        // if(pres && (pres != saved_key)){//æœ‰æ–°æŒ‰é”®è§¦å‘
 173   1        //  EEPROM_Write(&pres,8,1);
 174   1        // }
 175   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              06/25/2025 11:40:12 PAGE 4   

 176          
 177          void SEG_Process()
 178          {
 179   1        u8 i;
 180   1      
 181   1        // for (i = 0; i < 8; i++)
 182   1        // seg_buf[i] = password[1][i];
 183   1        
 184   1        if(segcnt)  return;
 185   1        segcnt = 1;
 186   1      
 187   1        if(error >= 3){//è¶…è¿‡ä¸‰æ¬¡ï¼Œåœæ­¢æ˜¾ç¤ºï¼Œç¦æ­¢è¾“å…¥
 188   2          for (i = 0; i < 8; i++){
 189   3            seg_buf[i] = 0x00;
 190   3          }
 191   2          return;
 192   2        }
 193   1      
 194   1        switch(mode)
 195   1        {
 196   2          case 0:{
 197   3            for (i = 0; i < 8; i++)
 198   3              seg_buf[i] = (pw_input[i] != 0x40) ? tab[pw_input[i]] : 0x40;//æ— è¾“å…¥æ˜¾ç¤º"-"
 199   3          };break;
 200   2          case 1:{
 201   3            // seg_buf[0] = (pw_input[0] != 0x40) ? tab[pw_input[0]] : (tab[12]|0x80);//"C."è¡¨ç¤ºå½“å‰åœ¨Clientæ¨
             -¡å¼
 202   3            if(pw_input[7] == 0x40){
 203   4              seg_buf[0] = tab[12]|0x80;//"C."è¡¨ç¤ºå½“å‰åœ¨Clientæ¨¡å¼
 204   4              seg_buf[1] = tab[user]|0x80;//å½“å‰ç”¨æˆ·ID
 205   4            }
 206   3            else{
 207   4              seg_buf[0] = (pw_input[0] != 0x40) ? tab[pw_input[0]] : 0x80;;//æœ‰è¾“å…¥åˆ™å˜ä¸ºç‚¹
 208   4              seg_buf[1] = (pw_input[1] != 0x40) ? tab[pw_input[1]] : 0x80;
 209   4            }
 210   3            for (i = 2; i < 8; i++)
 211   3              seg_buf[i] = (pw_input[i] != 0x40) ? tab[pw_input[i]] : 0x80;
 212   3          };break;
 213   2          case 2:{
 214   3            if(adflag){
 215   4              seg_buf[0] = tab[10]|0x80;//"A."è¡¨ç¤ºå½“å‰åœ¨Adminæ¨¡å¼
 216   4              seg_buf[1] = 0x40;//"-"
 217   4              seg_buf[2] = 0x40;
 218   4              seg_buf[3] = 0x40;
 219   4              seg_buf[4] = 0x40;
 220   4              seg_buf[5] = 0x40;
 221   4              if (user < USER_MAX){
 222   5                seg_buf[6] = tab[12]; //"C"
 223   5                seg_buf[7] = tab[user];
 224   5              }
 225   4              else{
 226   5                seg_buf[6] = tab[10];//"A"
 227   5                seg_buf[7] = tab[13];//"D"
 228   5              }
 229   4            }
 230   3            else{
 231   4              for (i = 0; i < 8; i++)
 232   4                seg_buf[i] = (pw_input[i] != 0x40) ? tab[pw_input[i]] : 0x80;//æ— è¾“å…¥æ˜¾ç¤º"."
 233   4            }
 234   3          };break;
 235   2        }
 236   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              06/25/2025 11:40:12 PAGE 5   

 237          
 238          void BEEP_Process(void)
 239          {
 240   1        if(~errflag && (error >= 3)){//å¯†ç é”™è¯¯é”å®šé•¿å“
 241   2          BEEP = 1;
 242   2          errflag = 1;
 243   2        }
 244   1        else if(errflag && (error < 3)){
 245   2          BEEP = 0;
 246   2          errflag = 0;
 247   2        }
 248   1      
 249   1        if(beepflag && ~BEEP)//å¯†ç æ­£ç¡®çŸ­å“
 250   1          BEEP = 1;
 251   1        else if(!beepflag && BEEP)
 252   1          BEEP = 0;
 253   1      }
 254          
 255          void main()
 256          {
 257   1        BEEP = 0;
 258   1        mPW_Read();
 259   1        Timer0_Init();
 260   1        UartInit();
 261   1        Stepper_Init();
 262   1        
 263   1        while(1){
 264   2          SEG_Process();
 265   2          KBD_Process();
 266   2          BEEP_Process();
 267   2        }
 268   1      }
 269          
 270          void T0ISR(void)  interrupt 1
 271          {
 272   1        Timer0_Reload();
 273   1        SEG_Display();
 274   1        
 275   1        if(++segcnt >= 50)  segcnt = 0;
 276   1        if(++kbdcnt >= 10)  kbdcnt = 0;
 277   1        // if(++flashcnt >= 500){
 278   1        //  flashcnt = 0;
 279   1        //  flash = ~flash;
 280   1        // }
 281   1      
 282   1        if(error >= 3){
 283   2          if(++errcnt >= 5000){
 284   3            errcnt = 0;
 285   3            error = 0;
 286   3          }
 287   2        }
 288   1        if(beepflag){
 289   2          if(++beepcnt >= 75){
 290   3            beepcnt = 0;
 291   3            beepflag = 0;
 292   3          }
 293   2        }
 294   1        stepflag = 1;
 295   1      }
 296          
 297          // void Uart_Rounite() interrupt 4 //WIFIæ•°æ®æ¥æ”¶
 298          // {
C51 COMPILER V9.60.0.0   MAIN                                                              06/25/2025 11:40:12 PAGE 6   

 299          //  RI = 0;
 300          //  receiveData = SBUF;
 301          //  Uart_Send(receiveData);
 302          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1094    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
